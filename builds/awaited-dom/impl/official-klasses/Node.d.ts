import { INode, IGetRootNodeOptions } from '../../base/interfaces/official';
import { ISuperNodeList, ISuperNode, ISuperDocument, ISuperElement } from '../../base/interfaces/super';
import { INodeProperties } from '../../base/official-klasses/Node';
export declare const getState: <C = INode, P = INodeProperties>(instance: C) => P, setState: <P = INodeProperties>(instance: INode, properties: P) => void;
declare const NodeBaseClass: {
    new (): {
        readonly ATTRIBUTE_NODE: number;
        readonly CDATA_SECTION_NODE: number;
        readonly COMMENT_NODE: number;
        readonly DOCUMENT_FRAGMENT_NODE: number;
        readonly DOCUMENT_NODE: number;
        readonly DOCUMENT_POSITION_CONTAINED_BY: number;
        readonly DOCUMENT_POSITION_CONTAINS: number;
        readonly DOCUMENT_POSITION_DISCONNECTED: number;
        readonly DOCUMENT_POSITION_FOLLOWING: number;
        readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
        readonly DOCUMENT_POSITION_PRECEDING: number;
        readonly DOCUMENT_TYPE_NODE: number;
        readonly ELEMENT_NODE: number;
        readonly ENTITY_NODE: number;
        readonly ENTITY_REFERENCE_NODE: number;
        readonly NOTATION_NODE: number;
        readonly PROCESSING_INSTRUCTION_NODE: number;
        readonly TEXT_NODE: number;
        readonly baseURI: Promise<string>;
        readonly childNodes: ISuperNodeList;
        readonly firstChild: ISuperNode;
        readonly isConnected: Promise<boolean>;
        readonly lastChild: ISuperNode;
        readonly nextSibling: ISuperNode;
        readonly nodeName: Promise<string>;
        readonly nodeType: Promise<number>;
        readonly nodeValue: Promise<string | null>;
        readonly ownerDocument: ISuperDocument;
        readonly parentElement: ISuperElement;
        readonly parentNode: ISuperNode;
        readonly previousSibling: ISuperNode;
        readonly textContent: Promise<string | null>;
        compareDocumentPosition(other: ISuperNode): Promise<number>;
        contains(other: ISuperNode | null): Promise<boolean>;
        getRootNode(options?: IGetRootNodeOptions | undefined): ISuperNode;
        hasChildNodes(): Promise<boolean>;
        isDefaultNamespace(namespace: string | null): Promise<boolean>;
        isEqualNode(otherNode: ISuperNode | null): Promise<boolean>;
        isSameNode(otherNode: ISuperNode | null): Promise<boolean>;
        lookupNamespaceURI(prefix: string | null): Promise<string | null>;
        lookupPrefix(namespace: string | null): Promise<string | null>;
        normalize(): Promise<void>;
        then<TResult1 = INode, TResult2 = never>(onfulfilled?: ((value: INode) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
    };
    readonly ATTRIBUTE_NODE: number;
    readonly CDATA_SECTION_NODE: number;
    readonly COMMENT_NODE: number;
    readonly DOCUMENT_FRAGMENT_NODE: number;
    readonly DOCUMENT_NODE: number;
    readonly DOCUMENT_POSITION_CONTAINED_BY: number;
    readonly DOCUMENT_POSITION_CONTAINS: number;
    readonly DOCUMENT_POSITION_DISCONNECTED: number;
    readonly DOCUMENT_POSITION_FOLLOWING: number;
    readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
    readonly DOCUMENT_POSITION_PRECEDING: number;
    readonly DOCUMENT_TYPE_NODE: number;
    readonly ELEMENT_NODE: number;
    readonly ENTITY_NODE: number;
    readonly ENTITY_REFERENCE_NODE: number;
    readonly NOTATION_NODE: number;
    readonly PROCESSING_INSTRUCTION_NODE: number;
    readonly TEXT_NODE: number;
};
export default class Node extends NodeBaseClass implements INode {
    get childNodes(): ISuperNodeList;
    get firstChild(): ISuperNode;
    get lastChild(): ISuperNode;
    get nextSibling(): ISuperNode;
    get ownerDocument(): ISuperDocument;
    get parentElement(): ISuperElement;
    get parentNode(): ISuperNode;
    get previousSibling(): ISuperNode;
    getRootNode(options?: IGetRootNodeOptions): ISuperNode;
}
export {};
