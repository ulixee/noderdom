import AwaitedHandler from '../AwaitedHandler';
import AwaitedPath from '../AwaitedPath';
import Constructable from '../Constructable';
import NodeAttacher from '../NodeAttacher';
import { ISuperDocument, ISuperHTMLCollection, ISuperHTMLElement, ISuperElement, ISuperNodeList } from '../interfaces/super';
import { INodeIsolate } from '../interfaces/isolate';
import { IParentNode, IDocumentType, IFeaturePolicy, IHTMLHeadElement, IDOMImplementation, ILocation, IDocumentReadyState, IVisibilityState } from '../interfaces/official';
import { INodeIsolateProperties } from '../isolate-mixins/NodeIsolate';
import { IParentNodeProperties } from '../official-mixins/ParentNode';
export declare const getState: <C = ISuperDocument, P = ISuperDocumentProperties>(instance: C) => P, setState: <P = ISuperDocumentProperties>(instance: ISuperDocument, properties: P) => void;
export declare const awaitedHandler: AwaitedHandler<ISuperDocument>;
export declare const nodeAttacher: NodeAttacher<ISuperDocument>;
export declare function SuperDocumentGenerator(NodeIsolate: Constructable<INodeIsolate>, ParentNode: Constructable<IParentNode>): {
    new (): {
        readonly URL: Promise<string>;
        readonly anchors: ISuperHTMLCollection;
        readonly body: ISuperHTMLElement;
        readonly characterSet: Promise<string>;
        readonly compatMode: Promise<string>;
        readonly contentType: Promise<string>;
        readonly cookie: Promise<string>;
        readonly designMode: Promise<string>;
        readonly dir: Promise<string>;
        readonly doctype: IDocumentType;
        readonly documentElement: ISuperElement;
        readonly documentURI: Promise<string>;
        readonly domain: Promise<string>;
        readonly embeds: ISuperHTMLCollection;
        readonly featurePolicy: IFeaturePolicy;
        readonly forms: ISuperHTMLCollection;
        readonly fullscreenEnabled: Promise<boolean>;
        readonly head: IHTMLHeadElement;
        readonly hidden: Promise<boolean>;
        readonly images: ISuperHTMLCollection;
        readonly implementation: IDOMImplementation;
        readonly lastModified: Promise<string>;
        readonly links: ISuperHTMLCollection;
        readonly location: ILocation;
        readonly plugins: ISuperHTMLCollection;
        readonly readyState: Promise<IDocumentReadyState>;
        readonly referrer: Promise<string>;
        readonly scripts: ISuperHTMLCollection;
        readonly scrollingElement: ISuperElement;
        readonly title: Promise<string>;
        readonly visibilityState: Promise<IVisibilityState>;
        exitFullscreen(): Promise<void>;
        exitPointerLock(): Promise<void>;
        getElementsByClassName(classNames: string): ISuperHTMLCollection;
        getElementsByName(elementName: string): ISuperNodeList;
        getElementsByTagName(qualifiedName: string): ISuperHTMLCollection;
        getElementsByTagNameNS(namespace: string | null, localName: string): ISuperHTMLCollection;
        hasFocus(): Promise<boolean>;
        then<TResult1 = ISuperDocument, TResult2 = never>(onfulfilled?: ((value: ISuperDocument) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
        readonly ATTRIBUTE_NODE: number;
        readonly CDATA_SECTION_NODE: number;
        readonly COMMENT_NODE: number;
        readonly DOCUMENT_FRAGMENT_NODE: number;
        readonly DOCUMENT_NODE: number;
        readonly DOCUMENT_POSITION_CONTAINED_BY: number;
        readonly DOCUMENT_POSITION_CONTAINS: number;
        readonly DOCUMENT_POSITION_DISCONNECTED: number;
        readonly DOCUMENT_POSITION_FOLLOWING: number;
        readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
        readonly DOCUMENT_POSITION_PRECEDING: number;
        readonly DOCUMENT_TYPE_NODE: number;
        readonly ELEMENT_NODE: number;
        readonly ENTITY_NODE: number;
        readonly ENTITY_REFERENCE_NODE: number;
        readonly NOTATION_NODE: number;
        readonly PROCESSING_INSTRUCTION_NODE: number;
        readonly TEXT_NODE: number;
        readonly baseURI: Promise<string>;
        readonly childNodes: ISuperNodeList;
        readonly firstChild: import("../interfaces/super").ISuperNode;
        readonly isConnected: Promise<boolean>;
        readonly lastChild: import("../interfaces/super").ISuperNode;
        readonly nextSibling: import("../interfaces/super").ISuperNode;
        readonly nodeName: Promise<string>;
        readonly nodeType: Promise<number>;
        readonly nodeValue: Promise<string | null>;
        readonly ownerDocument: ISuperDocument;
        readonly parentElement: ISuperElement;
        readonly parentNode: import("../interfaces/super").ISuperNode;
        readonly previousSibling: import("../interfaces/super").ISuperNode;
        readonly textContent: Promise<string | null>;
        compareDocumentPosition(other: import("../interfaces/super").ISuperNode): Promise<number>;
        contains(other: import("../interfaces/super").ISuperNode | null): Promise<boolean>;
        getRootNode(options?: import("../interfaces/official").IGetRootNodeOptions | undefined): import("../interfaces/super").ISuperNode;
        hasChildNodes(): Promise<boolean>;
        isDefaultNamespace(namespace: string | null): Promise<boolean>;
        isEqualNode(otherNode: import("../interfaces/super").ISuperNode | null): Promise<boolean>;
        isSameNode(otherNode: import("../interfaces/super").ISuperNode | null): Promise<boolean>;
        lookupNamespaceURI(prefix: string | null): Promise<string | null>;
        lookupPrefix(namespace: string | null): Promise<string | null>;
        normalize(): Promise<void>;
        readonly childElementCount: Promise<number>;
        readonly children: ISuperHTMLCollection;
        readonly firstElementChild: ISuperElement;
        readonly lastElementChild: ISuperElement;
        querySelector(selectors: string): ISuperElement;
        querySelectorAll(selectors: string): ISuperNodeList;
    };
};
export interface ISuperDocumentProperties extends INodeIsolateProperties, IParentNodeProperties {
    awaitedPath: AwaitedPath;
    awaitedOptions: any;
    readonly URL?: Promise<string>;
    readonly anchors?: ISuperHTMLCollection;
    readonly body?: ISuperHTMLElement;
    readonly characterSet?: Promise<string>;
    readonly compatMode?: Promise<string>;
    readonly contentType?: Promise<string>;
    readonly cookie?: Promise<string>;
    readonly designMode?: Promise<string>;
    readonly dir?: Promise<string>;
    readonly doctype?: IDocumentType;
    readonly documentElement?: ISuperElement;
    readonly documentURI?: Promise<string>;
    readonly domain?: Promise<string>;
    readonly embeds?: ISuperHTMLCollection;
    readonly featurePolicy?: IFeaturePolicy;
    readonly forms?: ISuperHTMLCollection;
    readonly fullscreenEnabled?: Promise<boolean>;
    readonly head?: IHTMLHeadElement;
    readonly hidden?: Promise<boolean>;
    readonly images?: ISuperHTMLCollection;
    readonly implementation?: IDOMImplementation;
    readonly lastModified?: Promise<string>;
    readonly links?: ISuperHTMLCollection;
    readonly location?: ILocation;
    readonly plugins?: ISuperHTMLCollection;
    readonly readyState?: Promise<IDocumentReadyState>;
    readonly referrer?: Promise<string>;
    readonly scripts?: ISuperHTMLCollection;
    readonly scrollingElement?: ISuperElement;
    readonly title?: Promise<string>;
    readonly visibilityState?: Promise<IVisibilityState>;
}
export declare const SuperDocumentPropertyKeys: string[];
export declare const SuperDocumentConstantKeys: string[];
